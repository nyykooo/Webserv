6.3. Campos do cabeçalho da resposta

   Os campos do cabeçalho da resposta são campos CGI ou campos de cabeçalho de extensão
   a serem interpretados pelo servidor, ou campos de cabeçalho específicos do protocolo
   a serem incluídos na resposta devolvida ao cliente.  Pelo menos um
   campo CGI DEVE ser fornecido; cada campo CGI NÃO DEVE aparecer mais de
   uma vez na resposta.  Os campos do cabeçalho da resposta têm a seguinte sintaxe:

      campo-do-cabeçalho    = campo-CGI | outro-campo
      campo-CGI       = Tipo-de-Conteúdo | Localização | Status
      outro-campo     = campo-de-protocolo | campo-de-extensão
      campo-de-protocolo  = campo-genérico
      campo-de-extensão = campo-genérico
      campo-genérico   = nome-do-campo “:” [ valor-do-campo ] NL
      nome-do-campo      = token
      valor-do-campo     = *( conteúdo-do-campo | LWSP )
      conteúdo-do-campo   = *( token | separador | string-entre-aspas )

   O nome do campo não diferencia maiúsculas de minúsculas.  Um valor de campo NULL é
   equivalente a um campo não enviado.  Observe que cada campo de cabeçalho em
   uma resposta CGI DEVE ser especificado em uma única linha; CGI/1.1 não
   suporta linhas de continuação.  Espaços em branco são permitidos entre o “:”
   e o valor do campo (mas não entre o nome do campo e o “:”), e
   também entre tokens no valor do campo.

6.3.1.  Tipo de conteúdo

O campo de resposta Tipo de conteúdo define o Tipo de mídia da Internet [6] do
corpo da entidade.

      Tipo de conteúdo = “Tipo de conteúdo:” tipo de mídia NL

   Se um corpo da entidade for retornado, o script DEVE fornecer um campo Tipo de conteúdo
   na resposta.  Se isso não for feito, o servidor NÃO DEVE
   tentar determinar o tipo de conteúdo correto.  O valor DEVE ser
   enviado sem modificações ao cliente, exceto por quaisquer alterações no parâmetro de conjunto de caracteres
  .

   A menos que seja definido de outra forma pelo sistema, o charset padrão assumido pelo
   cliente para tipos de mídia de texto é ISO-8859-1 se o protocolo for HTTP
   e US-ASCII caso contrário.  Portanto, o script DEVE incluir um parâmetro de charset
  .  Consulte a seção 3.4.1 da especificação HTTP/1.1 [4] para uma
   discussão sobre essa questão.

6.3.2.  Localização

   O campo de cabeçalho Localização é usado para especificar ao servidor que o
   script está a devolver uma referência a um documento em vez de um documento real
   (consulte as secções 6.2.3 e 6.2.4).  É um URI absoluto
   (opcionalmente com um identificador de fragmento), indicando que o
   cliente deve buscar o documento referenciado, ou um caminho URI local
   (opcionalmente com uma string de consulta), indicando que o servidor deve
   buscar o documento referenciado e devolvê-lo ao cliente como
   resposta.

      Localização        = local-Localização | cliente-Localização
      cliente-Localização = “Localização:” fragmento-URI NL
      local-Localização  = “Localização:” caminho-localquery NL
      fragmento-URI    = absoluteURI [ “#” fragmento ]
      fragmento        = *uric
      local-pathquery = abs-path [ “?” query-string ]
      abs-path        = “/” path-segments
      path-segments   = segment *( “/” segment )
      segment         = *pchar
      pchar           = unreserved | escaped | extra
      extra           = “:” | “@” | “&” | “=” | “+” | “$” | “,”

   A sintaxe de um absoluteURI é incorporada neste documento a partir
  da especificada na RFC 2396 [2] e na RFC 2732 [7].  Um absoluteURI válido
  começa sempre com o nome do esquema seguido de «:»; os nomes dos esquemas
  começam com uma letra e continuam com caracteres alfanuméricos, «+», «-» ou «.».
   O caminho URI local e a consulta devem ser um caminho absoluto, e não um
   caminho relativo ou NULL, e, portanto, devem começar com um “/”.

   Observe que qualquer corpo de mensagem anexado à solicitação (como para uma
   solicitação POST) pode não estar disponível para o recurso que é o destino
   do redirecionamento.


6.3.3.  Status

   O campo do cabeçalho Status contém um código de resultado inteiro de 3 dígitos que
   indica o nível de sucesso da tentativa do script de processar a
   solicitação.

      Status         = “Status:” código-de-status SP frase-de-motivo NL
      código-de-status    = “200” | “302” | ‘400’ | “501” | código-de-extensão
      código-de-extensão = 3dígitos
      frase-de-motivo  = *TEXTO

   O código de estado 200 ‘OK’ indica sucesso e é o valor padrão
   assumido para uma resposta de documento.  O código de estado 302 ‘Encontrado’ é usado
   com um campo de cabeçalho Localização e corpo da mensagem de resposta.  O código de estado
400 «Bad Request» pode ser utilizado para um formato de pedido desconhecido, tal como
   um CONTENT_TYPE em falta.  O código de estado 501 «Not Implemented» pode ser
   devolvido por um script se receber um REQUEST_METHOD não suportado.

   Outros códigos de estado válidos estão listados na secção 6.1.1 das especificações HTTP
   [1], [4] e também no Registro de Códigos de Status HTTP da IANA
   [8] e PODE ser usado além ou em vez dos listados
   acima.  O script DEVE verificar o valor de SERVER_PROTOCOL antes de
   usar códigos de status HTTP/1.1.  O script PODE rejeitar com o erro 405
   'Método Não Permitido' HTTP/1.1 feitas usando um método que ele
   não suporta.

   Observe que retornar um código de status de erro não significa necessariamente uma
   condição de erro com o próprio script.  Por exemplo, um script que
   é invocado como um manipulador de erros pelo servidor deve retornar o código
   apropriado para a condição de erro do servidor.

   A frase de motivo é uma descrição textual do erro a ser
   devolvida ao cliente para consumo humano.

6.3.4.  Campos de cabeçalho específicos do protocolo

   O script PODE devolver quaisquer outros campos de cabeçalho relacionados com a
   mensagem de resposta definida pela especificação para o SERVER_PROTOCOL
   (HTTP/1.0 [1] ou HTTP/1.1 [4]).  O servidor DEVE converter os dados do cabeçalho
   da sintaxe do cabeçalho CGI para a sintaxe do cabeçalho HTTP, se estas
   forem diferentes.  Por exemplo, a sequência de caracteres para nova linha (como
   US-ASCII LF do UNIX) usada por scripts CGI pode não ser a mesma que a
   usada pelo HTTP (US-ASCII CR seguido por LF).

   O script NÃO DEVE retornar nenhum campo de cabeçalho relacionado a
   questões de comunicação do lado do cliente e que possa afetar a capacidade do servidor
   de enviar a resposta ao cliente.  O servidor PODE remover
   quaisquer campos de cabeçalho retornados pelo cliente.  Ele DEVE resolver quaisquer
   conflitos entre os campos de cabeçalho retornados pelo script e os campos de cabeçalho
   que ele mesmo enviaria.

6.3.5.  Campos de cabeçalho de extensão

Pode haver campos de cabeçalho CGI adicionais definidos pela implementação,
   cujos nomes DEVEM começar com “X-CGI-”.  O servidor PODE ignorar
   (e excluir) quaisquer campos de cabeçalho não reconhecidos com nomes que comecem com "X-
   CGI-" recebidos do script.